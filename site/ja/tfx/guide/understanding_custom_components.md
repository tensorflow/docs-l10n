# TFX カスタムコンポーネントを理解する

TFX パイプラインを使うと、機械学習（ML）ワークフローを Apache Airflow、Apache Beacm、Kubeflow Pipelines などのオーケストレータに統合することができます。パイプラインはワークフローを一連のコンポーネントに編成し、コンポーネントごとに ML ワークフローのステップが実行されます。TFX 標準コンポーネントには ML ワークフローを簡単に構築し始める上で役立つことが実証された機能が備わっています。ワークフローにはカスタムコンポーネントを含めることも可能です。カスタムコンポーネントは次の方法で ML ワークフローを拡張できます。

- 独自のシステムからデータを取り込むなど、ニーズに合わせて調整されたコンポーネントを構築する
- データ拡張、アップサンプリング、またはダウンサンプリングを適用する
- 信頼区間またはオートエンコーダ再現誤差に基づき異常検出を実施する
- アラート通知や監視を行うヘルプデスクなどの外部システムと連結する
- ラベルの無い Example にラベルを適用する
- Python 以外の言語で構築されたツールを R によるデータ分析の実施といった ML ワークフローに組み込む

標準コンポーネントとカスタムコンポーネントを混在させることで、ニーズに合った ML ワークフローを構築できると同時に、TFX 標準コンポーネントに組み込まれたベストプラクティスを利用することができます。

このガイドでは、TFX カスタムコンポーネントを理解するために必要な概念とさまざまなカスタムコンポーネントの構築方法について説明します。

## TFX コンポーネントの構造

このセクションでは TFX の構造を概説します。TFX パイプラインを初めて使用する方は、[この TFX パイプラインを理解するためのガイドを読んで、基本概念を学習してください](understanding_tfx_pipelines)。

TFX コンポーネントは、コンポーネント仕様と Executor クラスで構成されており、コンポーネントのインターフェースクラスにパッケージ化されています。

*コンポーネント仕様*はコンポーネントの入力と出力のコントラクトが定義されており、このコントラクトにはコンポーネントの入力と出力のアーティファクトとコンポーネントの実行に使用されるパラメーターが指定されています。

コンポーネントの *Executor* クラスは、コンポーネントが実行する作業の実装を提供しています。

*コンポーネントインターフェース*クラスは、TFX パイプラインでコンポーネントとして使用できるように、コンポーネント仕様と Executor を組み合わせます。

### ランタイム時の TFX コンポーネント

パイプラインが TFX コンポーネントを実行する際、そのコンポーネントは 3 段階で実行されます。

1. まず、ドライバーがコンポーネント仕様を使用して必要なアーティファクトをメタデータストアから取得し、それらをコンポーネントに渡します。
2. 次に、Executor がコンポーネントの作業を実行します。
3. 最後に、パブリッシャがコンポーネント仕様と Executor から得た結果を使用して、コンポーネントの出力をメタデータストアに保存します。

![コンポーネントの構造](images/component.png)

ほとんどのカスタムコンポーネントの実装では、ドライバやパブリッシャをカスタマイズする必要はありません。通常、ドライバとパブリッシャへの変更は、パイプラインのコンポーネントとメタデータストアの対話を変更する場合にのみ必要となります。コンポーネントの入力、出力、またはパラメータのみを変更する場合は、*コンポーネント仕様*の変更のみが必要です。

## カスタムコンポーネントの種類

カスタムコンポーネントには、Python 関数ベースのコンポーネント、コンテナベースのコンポーネント、フルカスタムコンポーネントの 3 種類があります。以下のセクションでは、これらの種類の違いとそれぞれの使用ケースについて説明します。

### Python 関数ベースのコンポーネント

Python 関数ベースのコンポーネントは、コンテナベースまたはフルカスタムのコンポーネントよりも簡単に構築できます。このコンポーネントの仕様は Python 関数の引数に、引数が入力アーティファクトであるか、出力アーティファクトであるか、パラメータであるかを記述する型注釈を使って定義されています。関数本文はコンポーネントの Executor を定義し、コンポーネントインターフェースは関数に [`@component` decorator](https://github.com/tensorflow/tfx/blob/master/tfx/dsl/component/experimental/decorators.py){: .external} を追加することで定義されています。

関数を `@component` デコレータで装飾し、関数の引数を型注釈で定義することで、コンポーネント仕様、Executor、およびコンポーネントインターフェースを構築するという複雑な作業を行うことなくコンポーネントを作成することができます。

詳細は、[Python 関数ベースのコンポーネントを構築する](custom_function_component)をご覧ください。

### コンテナベースのコンポーネント

コンテナベースのコンポーネントには、コードを Docker コンテナで実行できるのであれば、任意の言語で記述されたコードをパイプラインに組み込める柔軟性が備わっています。そのため、コンテナベースのコンポーネントを作成するには、コンポーネントの実行可能を格納する Docker コンテナイメージを構築する必要があり、その後で [`create_container_component` 関数](https://github.com/tensorflow/tfx/blob/master/tfx/dsl/component/experimental/container_component.py){: .external}を呼び出して、次の項目を定義することが必要です。

- コンポーネント仕様の入力、出力、およびパラメータ
- コンポーネント Executor が実行するコンテナイメージとコマンド

この関数は、パイプライン定義に含めることのできるコンポーネントのインスタンスを返します。

この方法にはコードをコンテナイメージとしてパッケージがする必要性が伴うため、Python 関数ベースのコンポーネントを構築する方法よりも複雑ですが、Python 以外のコードをパイプラインに含める場合や複雑なランタイム環境や依存関係を使って Python コンポーネントを構築する場合には最適な方法です。

詳細は、[コンテナベースのコンポーネントを構築する](container_component)をご覧ください。

### フルカスタムコンポーネント

フルカスタムコンポーネントの場合、コンポーネント仕様、Executor、およびコンポーネントインターフェースクラスを定義してコンポーネントを構築することができます。この方法では、標準コンポーネントを再利用し、ユーザーのニーズに合わせて拡張することができます。

既存のコンポーネントが、開発しようとしているカスタムコンポーネントと同じ入力と出力を使って定義されている場合、既存のコンポーネントの Executor クラスをオーバーライドするだけで構築できます。つまり、コンポーネント仕様を再利用し、既存のコンポーネントから派生した新しい Executor を実装できるということです。このようにすることで、既存のコンポーネントに組み込まれた機能を再利用し、必要な機能のみを実装することができます。

ただし、新しいコンポーネントの入力と出力が固有のものであれば、まったく新しい*コンポーネント仕様*を定義することができます。

この方法は、既存のコンポーネント仕様と Executor を再利用する場合に最適な方法です。

詳細は、[フルカスタムコンポーネントを構築する](custom_component)をご覧ください。
