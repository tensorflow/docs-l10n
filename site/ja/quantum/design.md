# TensorFlow Quantum の設計

TensorFlow Quantum (TFQ) は、NISQ 時代の量子機械学習の問題のために設計されています。TFQ は量子回路の構築など、量子コンピューティングのプリミティブを TensorFlow エコシステムにもたらします。TensorFlow で構築されたモデルと演算は、これらのプリミティブを使用して、強力な量子古典ハイブリッドシステムを作成します。

TFQ を使用すると、研究者は量子データセット、量子モデル、および古典制御パラメータを使用して TensorFlow グラフを作成できます。これらはすべて、1 つの計算グラフでテンソルとして表されます。（古典的な確率的イベントにつながる）量子測定の結果は、TensorFlow の演算によって取得されます。トレーニングは、標準の [Keras](https://www.tensorflow.org/guide/keras/overview) API を使用して行われます。`tfq.datasets `モジュールを使用すると、研究者は新しい興味深い量子データセットを試すことができます。

## Cirq

<a href="https://github.com/quantumlib/Cirq" class="external">Circq</a> は、Google の量子プログラミングフレームワークで量子ビット、ゲート、回路、測定など、量子コンピュータまたはシミュレートされた量子コンピュータ上で量子回路を作成、変更、および呼び出すためのすべての基本的な演算を提供します。TensorFlow Quantum は、これらの Cirq プリミティブを使用して、バッチ計算、モデル構築、および勾配計算のために TensorFlow を拡張します。TensorFlow Quantum で効果を発揮するには、Cirq を活用することをお勧めします。

## TensorFlow Quantum プリミティブ

TensorFlow Quantum は、TensorFlow を量子コンピューティングハードウェアと統合するために必要なコンポーネントを実装するために、2 つのデータ型のプリミティブを導入します。

- *Quantum circuit*: これは、TensorFlow 内の <a href="https://github.com/quantumlib/Cirq" class="external">Circq</a> で定義された量子回路（`cirq.Circuit`）を表します。さまざまな実数値データポイントのバッチと同様に、さまざまなサイズの回路のバッチを作成します。
- *Pauli sum*: Cirq（`cirq.PauliSum`）で定義されたパウリ演算子のテンソル積の線形結合を表します。回路と同様に、さまざまなサイズの演算子のバッチを作成します。

### 基本的な演算

TensorFlow Quantum は、`tf.Tensor`内の量子回路プリミティブを使用して、これらの回路を処理し、意味のある出力を生成する演算を実装します。

TensorFlow の演算は最適化された C++ で記述されています。これらの演算は回路からサンプリングし、期待値を計算し、指定された回路によって生成された状態を出力します。柔軟でパフォーマンスの高い演算を作成するには、いくつかの課題があります。

1. 回路のサイズは同じではありません。シミュレートされた回路の場合、静的演算（`tf.matmul`や`tf.add`など）を作成してから、異なるサイズの回路で異なる数値に置き換えることはできません。これらの演算では、静的サイズの TensorFlow 計算グラフでは許可されていない動的サイズが許可されている必要があります。
2. 量子データは、異なる回路構造を引き起こす可能性があります。これは、TFQ 演算で動的サイズをサポートするもう 1 つの理由です。量子データは、基礎となる量子状態の構造変化を表すことができます。これは、元の回路への変更によって表されます。新しいデータポイントは実行時にスワップインおよびスワップアウトされるため、TensorFlow 計算グラフは構築後に変更できません。そのため、これらのさまざまな構造のサポートが必要になります。
3. `cirq.Circuits`は、一連の演算であるという点で計算グラフに似ています。一部には記号/プレースホルダーが含まれている場合があります。これを TensorFlow と可能な限り互換性を持たせることが重要です。

パフォーマンス上の理由から、Eigen（多くの TensorFlow 演算で使用される C ++ ライブラリ）は量子回路シミュレーションにはあまり適していません。代わりに、<a href="https://ai.googleblog.com/2019/10/quantum-supremacy-using-programmable.html" class="external">古典的コンピュータを超える量子実験</a>で使用される回路シミュレータが検証に使用され、TFQ 演算の基盤として拡張されます（すべて AVX2 および SSE 命令で記述されています）。物理的な量子コンピュータを使用する、同一の機能シグネチャを持つ演算が作成されました。シミュレートされた量子コンピュータと物理的な量子コンピュータの切り替えは、1 行のコードを変更するのと同じくらい簡単です。これらの演算は、<a href="https://github.com/tensorflow/quantum/blob/master/tensorflow_quantum/core/ops/circuit_execution_ops.py" class="external"><code>circuit_execution_ops.py</code></a>にあります。

### レイヤー

TensorFlow Quantum レイヤーは、`tf.keras.layers.Layer`インターフェースを使用して、サンプリング、期待値、状態計算を開発者に公開します。古典的な制御パラメータまたは読み出し演算用の回路レイヤーを作成すると便利です。さらに、バッチ回路、バッチ制御パラメータ値をサポートする高度な複雑さのレイヤーを作成し、バッチ読み出し演算を実行できます。例については、`tfq.layers.Sample`をご覧ください。

### 微分器

多くの TensorFlow 演算とは異なり、量子回路のオブザーバブルには、比較的簡単に計算できる勾配の式がありません。これは、古典的なコンピュータが量子コンピュータで実行されている回路からしかサンプルを読み取れないためです。

この問題を解決するために、`tfq.differentiators`モジュールはいくつかの標準的な微分手法を提供します。ユーザーは、（「実世界」の設定でのサンプルに基づく期待値の計算や実際の分析で）勾配を計算するための独自の方法を定義することもできます。多くの場合、有限差分法などでは解析/正確な環境で最も高速（実時間）に実行できです。（実時間の）速度は遅くなりますが、<a href="https://arxiv.org/abs/1811.11184" class="external">パラメータシフト</a>や<a href="https://arxiv.org/abs/1901.05374" class="external">確率的方法</a>などのより実用的な方法の方が多くの場合、効果的です。`tfq.differentiators.Differentiator`がインスタンス化され、`generate_differentiable_op`を使用して既存の演算にアタッチされます。または、`tfq.layers.Expectation`または` tfq.layers.SampledExpectation`のコンストラクタに渡されます。カスタム微分器を実装するには、`tfq.differentiators.Differentiator`クラスから継承します。サンプリングまたは状態ベクトル計算の勾配演算を定義するには、`tf.custom_gradient`を使用します。

### データセット

量子コンピューティングの分野が成長するにつれて、より多くの量子データとモデルの組み合わせが発生し、構造化された比較がより困難になります。`tfq.datasets`モジュールを量子機械学習タスクのデータソースとして使用することにより確実なモデルとパフォーマンスの構造化された比較が可能になります。

コミュニティからの多大な貢献により、`tfq.datasets`モジュールが成長し、透明性と再現性の高い研究が可能になることが期待されています。量子制御、フェルミ粒子シミュレーション、近相転移分類、量子センシングなどの慎重にキュレートされた問題はすべて、`tfq.datasets`に追加するのに最適な候補です。新しいデータセットを提案するには、<a href="https://github.com/tensorflow/quantum/issues">GitHub issue</a> を作成してください。
