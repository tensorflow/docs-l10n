# TFX 사용자 정의 구성 요소 이해하기

TFX 파이프라인을 사용하면 Apache Airflow, Apache Beam 및 Kubeflow Pipelines와 같은 오케스트레이터에서 머신러닝(ML) 워크플로를 오케스트레이션할 수 있습니다. 파이프라인은 각 구성 요소가 ML 워크플로의 단계를 수행하는 일련의 구성 요소로 워크플로를 구성합니다. TFX 표준 구성 요소는 ML 워크플로 빌드를 쉽게 시작할 수 있도록 입증된 기능을 제공합니다. 워크플로에 사용자 정의 구성 요소를 포함할 수도 있습니다. 사용자 정의 구성 요소를 사용하면 다음을 통해 ML 워크플로를 확장할 수 있습니다.

- 독점 시스템에서 데이터 수집과 같이 요구 사항에 맞게 조정된 구성 요소를 빌드합니다.
- 데이터 증가, 업샘플링 또는 다운샘플링을 적용합니다.
- 신뢰 구간 또는 autoencoder 재생 오류를 기반으로 이상 감지를 수행합니다.
- 경고 및 모니터링을 위해 헬프 데스크와 같은 외부 시스템과 상호 작용합니다.
- 레이블이 없는 예에 레이블을 적용합니다.
- R을 사용한 데이터 분석 수행과 같이 Python 이외의 언어로 빌드된 도구를 ML 워크플로에 통합합니다.

표준 구성 요소와 사용자 정의 구성 요소를 혼합하여 TFX 표준 구성 요소에 내장된 모범 사례를 활용하면서 요구 사항을 충족하는 ML 워크플로를 빌드할 수 있습니다.

이 가이드에서는 TFX 사용자 정의 구성 요소를 이해하는 데 필요한 개념과 사용자 정의 구성 요소를 빌드할 수 있는 다양한 방법에 대해 설명합니다.

## TFX 구성 요소의 구성

이 섹션에서는 TFX 구성 요소의 구성에 대한 높은 수준의 개요를 제공합니다. TFX 파이프라인을 처음 사용하는 경우 [TFX 파이프라인 이해 가이드를 읽고 핵심 개념을 파악하세요](understanding_tfx_pipelines).

TFX 구성 요소는 구성 요소 인터페이스 클래스에 패키징된 구성 요소 사양과 실행자 클래스로 구성됩니다.

*구성 요소 사양*은 구성 요소의 입력 및 출력 계약을 정의합니다. 이 계약은 구성 요소의 입력 및 출력 결과물과 구성 요소 실행에 사용되는 매개변수를 지정합니다.

구성 요소의 *실행자* 클래스는 구성 요소가 수행하는 작업에 대한 구현을 제공합니다.

*구성 요소 인터페이스* 클래스는 TFX 파이프라인에서 구성 요소로 사용하기 위해 구성 요소 사양을 실행자와 결합합니다.

### 런타임 시 TFX 구성 요소

파이프라인이 TFX 구성 요소를 실행할 때 구성 요소는 다음 3단계로 실행됩니다.

1. 먼저 드라이버는 구성 요소 사양을 사용하여 메타데이터 저장소에서 필요한 아티팩트를 검색하고 이를 구성 요소에 전달합니다.
2. 다음으로 실행자는 구성 요소의 작업을 수행합니다.
3. 그런 다음 게시자는 구성 요소 사양과 실행자의 결과를 사용하여 구성 요소의 출력을 메타데이터 저장소에 저장합니다.

![Component Anatomy](images/component.png)

대부분의 사용자 정의 구성 요소 구현에서는 드라이버 또는 게시자를 사용자 정의할 필요가 없습니다. 일반적으로 드라이버 및 게시자에 대한 수정은 파이프라인 구성 요소와 메타데이터 저장소 간의 상호 작용을 변경하려는 경우에만 필요합니다. 구성 요소의 입력, 출력 또는 매개변수만 변경하려면 *구성 요소 사양*만 수정하면 됩니다.

## 사용자 정의 구성 요소의 유형

사용자 정의 구성 요소에는 Python 함수 기반 구성 요소, 컨테이너 기반 구성 요소 및 완전 사용자 정의 구성 요소의 3가지 유형이 있습니다. 다음 섹션에서는 다양한 유형의 구성 요소와 각 접근 방식을 사용해야 하는 경우에 대해 설명합니다.

### Python 함수 기반 구성 요소

Python 함수 기반 구성 요소는 컨테이너 기반 구성 요소 또는 완전 사용자 정의 구성 요소보다 빌드하기가 더 쉽습니다. 구성 요소 사양은 인수가 입력 아티팩트, 출력 아티팩트 또는 매개변수인지를 설명하는 유형 주석을 사용하여 Python 함수의 인수에 정의됩니다. 함수 본문은 구성 요소의 실행자를 정의합니다. 구성 요소 인터페이스는 함수에 [`@component` 데코레이터](https://github.com/tensorflow/tfx/blob/master/tfx/dsl/component/experimental/decorators.py){: .external}를 추가하여 정의됩니다.

`@component` 데코레이터로 함수를 데코레이팅하고 유형 주석으로 함수 인수를 정의하면 구성 요소 사양, 실행자 및 구성 요소 인터페이스를 빌드하는 복잡성 없이 구성 요소를 만들 수 있습니다.

[Python 함수 기반 구성 요소를 빌드](custom_function_component)하는 방법을 알아보세요.

### 컨테이너 기반 구성 요소

컨테이너 기반 구성 요소는 Docker 컨테이너에서 해당 코드를 실행할 수 있는 한 모든 언어로 작성된 코드를 파이프라인에 통합할 수 있는 유연성을 제공합니다. 컨테이너 기반 구성 요소를 만들려면 구성 요소의 실행 코드가 포함된 Docker 컨테이너 이미지를 빌드해야 합니다. 그런 다음 [`create_container_component` 함수](https://github.com/tensorflow/tfx/blob/master/tfx/dsl/component/experimental/container_component.py){: .external}를 호출하여 다음을 정의해야 합니다.

- 구성 요소 사양의 입력, 출력 및 매개변수
- 구성 요소 실행자가 실행하는 컨테이너 이미지 및 명령

이 함수는 파이프라인 정의에 포함할 수 있는 구성 요소의 인스턴스를 반환합니다.

이 접근 방식은 코드를 컨테이너 이미지로 패키징해야 하므로 Python 함수 기반 구성 요소를 빌드하는 것보다 더 복잡합니다. 이 접근 방식은 파이프라인에 Python이 아닌 코드를 포함하거나, 복잡한 런타임 환경 또는 종속성이 있는 Python 구성 요소를 빌드하는 데 가장 적합합니다.

[컨테이너 기반 구성 요소를 빌드](container_component)하는 방법을 알아보세요.

### 완전 사용자 정의 구성 요소

완전 사용자 정의 구성 요소를 사용하면 구성 요소 사양, 실행자 및 구성 요소 인터페이스 클래스를 정의하여 구성 요소를 빌드할 수 있습니다. 이 접근 방식을 사용하면 필요에 맞게 표준 구성 요소를 다시 사용하고 확장할 수 있습니다.

기존 구성 요소가 개발 중인 사용자 정의 구성 요소와 같은 입력 및 출력으로 정의되면 기존 구성 요소의 실행자 클래스를 간단하게 재정의할 수 있습니다. 즉, 구성 요소 사양을 다시 사용하고 기존 구성 요소에서 파생되는 새 실행자를 구현할 수 있습니다. 이러한 방식으로 기존 구성 요소에 내장된 기능을 다시 사용하고 필요한 기능만 구현합니다.

하지만 새 구성 요소의 입력 및 출력이 고유한 경우 완전히 새로운 *구성 요소 사양*을 정의할 수 있습니다.

이 접근 방식은 기존 구성 요소 사양 및 실행자를 다시 사용하는 데 가장 적합합니다.

[완전 사용자 정의 구성 요소를 빌드](custom_component)하는 방법을 알아보세요.
